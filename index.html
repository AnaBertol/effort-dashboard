<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visualização de Esforço - Planejamento de Projetos</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
            background: #FAF9FA;
            color: #373737;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            position: relative;
        }

        .language-selector {
            position: absolute;
            top: 0;
            right: 0;
            display: flex;
            gap: 10px;
            z-index: 100;
        }

        .language-option {
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 8px 12px;
            background: white;
            border: 2px solid #ddd;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 14px;
            font-weight: 500;
        }

        .language-option:hover {
            border-color: #6F02FD;
        }

        .language-option.active {
            border-color: #6F02FD;
            background: #6F02FD;
            color: white;
        }

        h1 {
            color: #6F02FD;
            font-size: 48px;
            font-weight: 300;
            margin-bottom: 30px;
            letter-spacing: -2px;
        }

        .controls {
            background: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            margin-bottom: 30px;
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
            align-items: flex-end;
        }

        .control-group {
            flex: 1;
            min-width: 200px;
        }

        .control-label {
            display: block;
            font-weight: 600;
            margin-bottom: 10px;
            color: #373737;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .upload-area {
            border: 2px dashed #6F02FD;
            border-radius: 8px;
            padding: 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            background: white;
            margin-bottom: 30px;
        }

        .upload-area:hover {
            border-color: #2C0165;
            background: #f5f3ff;
        }

        .upload-area.drag-over {
            border-color: #2C0165;
            background: #e8e0ff;
        }

        .upload-input {
            display: none;
        }

        select, input[type="date"], input[type="number"] {
            width: 100%;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        select:focus, input[type="date"]:focus, input[type="number"]:focus {
            outline: none;
            border-color: #6F02FD;
        }

        .toggle-buttons {
            display: flex;
            gap: 5px;
            background: #f0f0f0;
            padding: 3px;
            border-radius: 6px;
            overflow: hidden;
        }

        .toggle-button {
            padding: 8px 16px;
            border: none;
            background: transparent;
            cursor: pointer;
            border-radius: 4px;
            font-size: 14px;
            transition: all 0.3s;
        }

        .toggle-button.active {
            background: #6F02FD;
            color: white;
        }

        .progress-button {
            padding: 12px 24px;
            background: #2C0165;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            cursor: pointer;
            transition: background 0.2s;
            margin-bottom: 20px;
        }

        .progress-button:hover {
            background: #6F02FD;
        }

        .filter-info {
            background: #f5f5f5;
            padding: 15px 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-size: 14px;
            color: #666;
            text-align: center;
        }

        .filter-info .reset-button {
            padding: 8px 16px;
            background: #666;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
            margin-left: 10px;
            font-size: 13px;
        }

        .filter-info .reset-button:hover {
            background: #888;
        }

        .visualization-container {
            background: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            margin-bottom: 30px;
            display: none;
        }

        .visualization-container.active {
            display: block;
        }

        #chart {
            width: 100%;
            overflow-x: auto;
        }

        .legend {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            margin-bottom: 20px;
            padding: 20px;
            background: #f5f5f5;
            border-radius: 8px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            cursor: pointer;
            transition: opacity 0.3s;
            user-select: none;
        }

        .legend-item:hover {
            opacity: 0.7;
        }

        .legend-item.inactive {
            opacity: 0.4;
        }

        .legend-item.inactive .legend-color {
            background: #ccc !important;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
        }

        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 12px;
            border-radius: 6px;
            font-size: 13px;
            pointer-events: none;
            z-index: 1000;
            display: none;
            max-width: 300px;
        }

        .tooltip-title {
            font-weight: bold;
            margin-bottom: 5px;
            color: #9B7EDE;
        }

        .tooltip-info {
            margin-bottom: 3px;
        }

        .axis text {
            font-size: 12px;
            fill: #666;
        }

        .axis line,
        .axis path {
            stroke: #ddd;
        }

        .grid line {
            stroke: #f0f0f0;
            stroke-dasharray: 2,2;
        }

        .reference-line {
            stroke: #e0e0e0;
            stroke-width: 1;
            stroke-dasharray: 3,3;
        }

        .reference-text {
            font-size: 10px;
            fill: #999;
            text-anchor: end;
        }

        /* Estilos para visualização de progresso */
        .progress-controls {
            background: #f5f5f5;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: flex;
            gap: 20px;
            align-items: flex-end;
        }

        .progress-control {
            flex: 1;
            min-width: 200px;
        }

        .progress-control label {
            display: block;
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 8px;
            color: #373737;
        }

        .progress-control input,
        .progress-control select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        .project-card {
            background: white;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            display: flex;
            overflow: hidden;
        }

        .project-progress-bar {
            width: 60px;
            background: #f0f0f0;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: background 0.2s;
        }

        .project-progress-bar:hover {
            background: #e0e0e0;
        }

        .progress-fill {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: #6CDADE;
            transition: height 0.3s ease;
            pointer-events: none;
        }

        .progress-text {
            position: relative;
            z-index: 1;
            font-weight: 600;
            font-size: 14px;
            color: #373737;
            white-space: nowrap;
        }

        .progress-input-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            z-index: 1100;
            min-width: 300px;
        }

        .modal-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 1099;
        }

        .modal-title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 20px;
            color: #373737;
        }

        .modal-input {
            width: 100%;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 4px;
            font-size: 16px;
            margin-bottom: 20px;
            text-align: center;
        }

        .modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        .modal-button {
            padding: 8px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        .modal-button.primary {
            background: #6F02FD;
            color: white;
        }

        .modal-button.secondary {
            background: #ddd;
            color: #373737;
        }

        .project-content {
            flex: 1;
            padding: 20px;
            overflow-x: auto;
        }

        .project-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .project-name {
            font-size: 18px;
            font-weight: 600;
            color: #373737;
        }

        .project-stats {
            display: flex;
            gap: 20px;
            font-size: 14px;
            color: #666;
            align-items: center;
        }

        .timeline-chart {
            margin-top: 10px;
            height: 130px;
            overflow-x: auto;
            overflow-y: hidden;
        }

        .month-bar {
            cursor: pointer;
            transition: opacity 0.2s;
        }

        .month-bar:hover {
            opacity: 0.8;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
</head>
<body>
    <div class="container">
        <div class="language-selector">
            <div class="language-option active" id="pt-br" onclick="changeLanguage('pt-br')">
                <span>PT-BR</span>
            </div>
            <div class="language-option" id="en-us" onclick="changeLanguage('en-us')">
                <span>EN</span>
            </div>
        </div>

        <h1 id="main-title">Visualização de Esforço</h1>

        <div class="upload-area" id="uploadArea">
            <input type="file" id="fileInput" class="upload-input" accept=".csv">
            <div style="font-size: 20px; color: #6F02FD; margin-bottom: 10px;" id="upload-title">📊 Carregar arquivo CSV</div>
            <div style="font-size: 14px; color: #666;" id="upload-subtitle">Arraste o arquivo aqui ou clique para selecionar</div>
        </div>

        <button class="progress-button" id="progressViewBtn" onclick="toggleProgressView()" style="display: none;">
            <span id="progress-btn-text">📈 Visualizar Progresso por Projeto</span>
        </button>

        <div class="controls" id="controls" style="display: none;">
            <div class="control-group">
                <label class="control-label" id="viz-type-label">Tipo de Visualização</label>
                <div class="toggle-buttons">
                    <button class="toggle-button active" id="stackedBtn" onclick="setVisualizationType('stacked')" data-key="stacked-bars">Barras Empilhadas</button>
                    <button class="toggle-button" id="separateBtn" onclick="setVisualizationType('separate')" data-key="separate-charts">Gráficos Separados</button>
                </div>
            </div>

            <div class="control-group">
                <label class="control-label" id="group-by-label">Agrupar por</label>
                <div class="toggle-buttons">
                    <button class="toggle-button active" id="typeBtn" onclick="setGroupingCategory('type')" data-key="by-type">Por Tipo</button>
                    <button class="toggle-button" id="assigneeBtn" onclick="setGroupingCategory('assignee')" data-key="by-person">Por Pessoa</button>
                </div>
            </div>
        </div>

        <div class="filter-info" id="filterInfo" style="display: none;">
            <span id="filter-info-text">Clique no ano ou mês no eixo do gráfico para filtrar período</span>
            <button class="reset-button" onclick="resetDateRange()" id="resetDateBtn" data-key="show-full-period">
                Mostrar Período Completo
            </button>
        </div>

        <div class="progress-controls" id="progressControls" style="display: none;">
            <div class="progress-control">
                <label id="reference-month-label">Mês de Referência:</label>
                <select id="referenceMonth" onchange="updateProgressCalculations()"></select>
            </div>
            <button class="progress-button" onclick="toggleProgressView()" id="back-btn" data-key="back">
                ← Voltar
            </button>
        </div>

        <div class="visualization-container" id="visualizationContainer">
            <div class="legend" id="legend"></div>
            <div id="chart"></div>
        </div>
    </div>

    <div class="tooltip" id="tooltip"></div>

    <script>
        // Sistema de tradução
        let currentLanguage = 'pt-br';
        
        const translations = {
            'pt-br': {
                'main-title': 'Visualização de Esforço',
                'upload-title': '📊 Carregar arquivo CSV',
                'upload-subtitle': 'Arraste o arquivo aqui ou clique para selecionar',
                'progress-btn-text': '📈 Visualizar Progresso por Projeto',
                'viz-type-label': 'Tipo de Visualização',
                'stacked-bars': 'Barras Empilhadas',
                'separate-charts': 'Gráficos Separados',
                'group-by-label': 'Agrupar por',
                'by-type': 'Por Tipo',
                'by-person': 'Por Pessoa',
                'filter-info-text': 'Clique no ano ou mês no eixo do gráfico para filtrar período',
                'show-full-period': 'Mostrar Período Completo',
                'reference-month-label': 'Mês de Referência:',
                'back': '← Voltar',
                'effort-label': 'Esforço',
                'today': 'Hoje',
                'week-short': 'Sem:',
                'unassigned': 'Não atribuído',
                'no-file-error': 'Por favor, selecione um arquivo CSV',
                'file-read-error': 'Erro ao ler o arquivo: ',
                'no-valid-tasks': 'Nenhuma tarefa válida encontrada.\n\nVerifique se o arquivo possui:\n- Coluna \'Task\' preenchida\n- Coluna \'Due Date\' preenchida\n- Coluna \'Effort\' com valores numéricos\n\nTarefas processadas: {valid}\nTarefas inválidas: {invalid}',
                'project': 'Projeto',
                'date': 'Data',
                'project-effort': 'Esforço do projeto',
                'total-effort-in': 'Esforço total em',
                'total-effort-of': 'Esforço total de',
                'people-in-project': 'Pessoas neste projeto:',
                'work-types': 'Tipos de trabalho:',
                'total-general-effort': 'Esforço total geral',
                'remaining-project-percentage': '% Restante do Projeto em {year} - {project}',
                'inform-percentage': 'Informe quanto % do projeto ainda resta a ser realizado no ano {year}:',
                'completed-effort-year': 'Esforço concluído no {year}:',
                'remaining-effort-year': 'Esforço restante no {year}:',
                'total-planned-year': 'Total planejado para {year}:',
                'cancel': 'Cancelar',
                'save': 'Salvar',
                'no-future-activities': 'Sem atividades futuras no ano {year} a partir do mês de referência',
                'total-year': 'Total {year}:',
                'completed': 'Concluído',
                'accomplished': 'Realizado',
                'lines-ignored': 'linhas foram ignoradas por não terem dados válidos.',
                'total': 'Total',
                'completed-short': 'Concluído',
                'remaining': 'Restante',
                'points': 'pontos',
                'january': 'janeiro',
                'february': 'fevereiro',
                'march': 'março',
                'april': 'abril',
                'may': 'maio',
                'june': 'junho',
                'july': 'julho',
                'august': 'agosto',
                'september': 'setembro',
                'october': 'outubro',
                'november': 'novembro',
                'december': 'dezembro',
                'jan': 'jan',
                'feb': 'fev',
                'mar': 'mar',
                'apr': 'abr',
                'may-short': 'mai',
                'jun': 'jun',
                'jul': 'jul',
                'aug': 'ago',
                'sep': 'set',
                'oct': 'out',
                'nov': 'nov',
                'dec': 'dez'
            },
            'en-us': {
                'main-title': 'Effort Visualization',
                'upload-title': '📊 Load CSV file',
                'upload-subtitle': 'Drag file here or click to select',
                'progress-btn-text': '📈 View Project Progress',
                'viz-type-label': 'Visualization Type',
                'stacked-bars': 'Stacked Bars',
                'separate-charts': 'Separate Charts',
                'group-by-label': 'Group by',
                'by-type': 'By Type',
                'by-person': 'By Person',
                'filter-info-text': 'Click on year or month in chart axis to filter period',
                'show-full-period': 'Show Full Period',
                'reference-month-label': 'Reference Month:',
                'back': '← Back',
                'effort-label': 'Effort',
                'today': 'Today',
                'week-short': 'Wk:',
                'unassigned': 'Unassigned',
                'no-file-error': 'Please select a CSV file',
                'file-read-error': 'Error reading file: ',
                'no-valid-tasks': 'No valid tasks found.\n\nPlease check if the file has:\n- \'Task\' column filled\n- \'Due Date\' column filled\n- \'Effort\' column with numeric values\n\nProcessed tasks: {valid}\nInvalid tasks: {invalid}',
                'project': 'Project',
                'date': 'Date',
                'project-effort': 'Project effort',
                'total-effort-in': 'Total effort in',
                'total-effort-of': 'Total effort of',
                'people-in-project': 'People in this project:',
                'work-types': 'Work types:',
                'total-general-effort': 'Total general effort',
                'remaining-project-percentage': '% Remaining of Project in {year} - {project}',
                'inform-percentage': 'Enter what % of the project still remains to be completed in {year}:',
                'completed-effort-year': 'Completed effort in {year}:',
                'remaining-effort-year': 'Remaining effort in {year}:',
                'total-planned-year': 'Total planned for {year}:',
                'cancel': 'Cancel',
                'save': 'Save',
                'no-future-activities': 'No future activities in {year} from reference month',
                'total-year': 'Total {year}:',
                'completed': 'Completed',
                'accomplished': 'Accomplished',
                'lines-ignored': 'lines were ignored for not having valid data.',
                'total': 'Total',
                'completed-short': 'Completed',
                'remaining': 'Remaining',
                'points': 'points',
                'january': 'January',
                'february': 'February',
                'march': 'March',
                'april': 'April',
                'may': 'May',
                'june': 'June',
                'july': 'July',
                'august': 'August',
                'september': 'September',
                'october': 'October',
                'november': 'November',
                'december': 'December',
                'jan': 'Jan',
                'feb': 'Feb',
                'mar': 'Mar',
                'apr': 'Apr',
                'may-short': 'May',
                'jun': 'Jun',
                'jul': 'Jul',
                'aug': 'Aug',
                'sep': 'Sep',
                'oct': 'Oct',
                'nov': 'Nov',
                'dec': 'Dec'
            }
        };

        // Função para trocar idioma
        function changeLanguage(lang) {
            currentLanguage = lang;
            
            // Atualizar seletores visuais
            document.getElementById('pt-br').classList.toggle('active', lang === 'pt-br');
            document.getElementById('en-us').classList.toggle('active', lang === 'en-us');
            
            // Atualizar todos os textos
            updateAllTexts();
            
            // Se há dados carregados, reprocessar e atualizar visualização
            if (tasksData.length > 0) {
                processData();
                updateVisualization();
            }
        }

        // Função para atualizar todos os textos da página
        function updateAllTexts() {
            const texts = translations[currentLanguage];
            
            // Atualizar elementos com IDs
            Object.keys(texts).forEach(key => {
                const element = document.getElementById(key);
                if (element) {
                    element.textContent = texts[key];
                }
            });
            
            // Atualizar botões com data-key
            document.querySelectorAll('[data-key]').forEach(element => {
                const key = element.getAttribute('data-key');
                if (texts[key]) {
                    element.textContent = texts[key];
                }
            });
        }

        // Função para obter texto traduzido
        function t(key, replacements = {}) {
            let text = translations[currentLanguage][key] || key;
            
            // Substituir placeholders
            Object.keys(replacements).forEach(placeholder => {
                text = text.replace(`{${placeholder}}`, replacements[placeholder]);
            });
            
            return text;
        }

        // Função para traduzir nomes de meses
        function translateMonth(monthName, short = false) {
            const monthMap = {
                'pt-br': {
                    'January': short ? 'Jan' : 'Janeiro',
                    'February': short ? 'Fev' : 'Fevereiro', 
                    'March': short ? 'Mar' : 'Março',
                    'April': short ? 'Abr' : 'Abril',
                    'May': short ? 'Mai' : 'Maio',
                    'June': short ? 'Jun' : 'Junho',
                    'July': short ? 'Jul' : 'Julho',
                    'August': short ? 'Ago' : 'Agosto',
                    'September': short ? 'Set' : 'Setembro',
                    'October': short ? 'Out' : 'Outubro',
                    'November': short ? 'Nov' : 'Novembro',
                    'December': short ? 'Dez' : 'Dezembro',
                    'Jan': 'Jan', 'Feb': 'Fev', 'Mar': 'Mar', 'Apr': 'Abr',
                    'May': 'Mai', 'Jun': 'Jun', 'Jul': 'Jul', 'Aug': 'Ago',
                    'Sep': 'Set', 'Oct': 'Out', 'Nov': 'Nov', 'Dec': 'Dez'
                },
                'en-us': {
                    'janeiro': short ? 'Jan' : 'January',
                    'fevereiro': short ? 'Feb' : 'February',
                    'março': short ? 'Mar' : 'March', 
                    'abril': short ? 'Apr' : 'April',
                    'maio': short ? 'May' : 'May',
                    'junho': short ? 'Jun' : 'June',
                    'julho': short ? 'Jul' : 'July',
                    'agosto': short ? 'Aug' : 'August',
                    'setembro': short ? 'Sep' : 'September',
                    'outubro': short ? 'Oct' : 'October',
                    'novembro': short ? 'Nov' : 'November',
                    'dezembro': short ? 'Dec' : 'December',
                    'jan': 'Jan', 'fev': 'Feb', 'mar': 'Mar', 'abr': 'Apr',
                    'mai': 'May', 'jun': 'Jun', 'jul': 'Jul', 'ago': 'Aug',
                    'set': 'Sep', 'out': 'Oct', 'nov': 'Nov', 'dez': 'Dec'
                }
            };

            const map = monthMap[currentLanguage];
            return map && map[monthName] ? map[monthName] : monthName;
        }

        // Variáveis globais
        let tasksData = [];
        let processedData = [];
        let projectProgressData = [];
        let currentVisualizationType = 'stacked';
        let currentGroupingCategory = 'type';
        let highlightedProject = null;
        let selectedProject = null;
        let originalDateRange = { start: null, end: null };
        let progressMode = false;
        let referenceMonth = null;
        let projectRemainingPercentages = {};
        let visibleCategories = {}; // Controla quais categorias estão visíveis
        
        // Cores por tipo - DEFINITIVAS
        const typeColors = {
            'Graphic Design': '#6CDADE',           // Azul claro
            'Data Analysis & Dataviz': '#6F02FD',  // Roxo principal
            'Development & Tech': '#3570DF',       // Azul
            'Strategic Consulting': '#666666',     // Cinza
            'Project Management': '#EDFF19',       // Amarelo
            'UX & UI Design': '#FFA4E8',          // Rosa
            'UX/UI Design': '#FFA4E8'             // Rosa (caso alternativo)
        };

        // Cores para pessoas
        let assigneeColors = {};
        const assigneeColorPalette = [
            '#6F02FD', '#3570DF', '#6CDADE', '#FFA4E8', '#2C0165', 
            '#FF6B6B', '#4ECDC4', '#45B7D1', '#E6B800', '#BB8FCE',
            '#52BE80', '#F39C12', '#E74C3C', '#3498DB', '#9B59B6'
        ];

        // Função para simplificar nome/email - genérica para qualquer email
        function simplifyAssignee(assignee) {
            if (!assignee) return null;
            
            // Se contém @, é email - extrair primeiro nome
            if (assignee.includes('@')) {
                // Pegar parte antes do @
                const localPart = assignee.split('@')[0];
                // Pegar primeira parte (antes de ponto ou underscore)
                const firstName = localPart.split(/[._]/)[0];
                // Capitalizar primeira letra
                return firstName.charAt(0).toUpperCase() + firstName.slice(1).toLowerCase();
            }
            
            // Se não é email, retorna o valor original
            return assignee;
        }

        // Função para normalizar valores de esforço
        function normalizeEffortValue(value) {
            if (value === null || value === undefined || value === '') {
                return 0;
            }
            
            // Se já é número, retorna
            if (typeof value === 'number') {
                return isNaN(value) ? 0 : value;
            }
            
            // Se é string, limpa e converte
            if (typeof value === 'string') {
                // Remove aspas, espaços e outros caracteres
                const cleaned = value.replace(/["\s]/g, '');
                const parsed = parseFloat(cleaned);
                return isNaN(parsed) ? 0 : parsed;
            }
            
            // Tenta converter qualquer outro tipo
            const parsed = parseFloat(value);
            return isNaN(parsed) ? 0 : parsed;
        }

        // Função para normalizar headers (remove espaços)
        function normalizeHeaders(data) {
            return data.map(row => {
                const normalizedRow = {};
                Object.keys(row).forEach(key => {
                    const normalizedKey = key.trim();
                    normalizedRow[normalizedKey] = row[key];
                });
                return normalizedRow;
            });
        }

        // Configurar upload
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');

        uploadArea.addEventListener('click', () => fileInput.click());
        
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('drag-over');
        });

        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('drag-over');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('drag-over');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFile(files[0]);
            }
        });

        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFile(e.target.files[0]);
            }
        });

        // Processar arquivo
        function handleFile(file) {
            if (!file.name.endsWith('.csv')) {
                alert(t('no-file-error'));
                return;
            }

            Papa.parse(file, {
                header: true,
                dynamicTyping: false,
                skipEmptyLines: true,
                delimitersToGuess: [',', '\t', '|', ';'],
                complete: function(results) {
                    const normalizedData = normalizeHeaders(results.data);

                    const processedTasks = [];
                    let validCount = 0;
                    let invalidCount = 0;

                    normalizedData.forEach((row, index) => {
                        const originalEffort = row.Effort || row.effort;
                        const normalizedEffort = normalizeEffortValue(originalEffort);
                        
                        const hasTask = row.Task && row.Task.toString().trim() !== '';
                        const hasDueDate = row['Due Date'] && row['Due Date'].toString().trim() !== '';
                        const hasEffort = normalizedEffort > 0;

                        if (hasTask && hasDueDate && hasEffort) {
                            row.Effort = normalizedEffort;
                            processedTasks.push(row);
                            validCount++;
                        } else {
                            invalidCount++;
                        }
                    });

                    tasksData = processedTasks;

                    if (tasksData.length === 0) {
                        alert(t('no-valid-tasks', {valid: validCount, invalid: invalidCount}));
                        return;
                    }

                    if (invalidCount > 0) {
                        console.warn(`${invalidCount} ${t('lines-ignored')}`);
                    }

                    initializeVisualization();
                },
                error: function(error) {
                    alert(t('file-read-error') + error.message);
                }
            });
        }

        // Inicializar visualização
        function initializeVisualization() {
            // Processar datas
            tasksData.forEach(task => {
                task.endDate = new Date(task['Due Date']);
                task.startDate = task.Start ? new Date(task.Start) : new Date(task.endDate.getTime() - 7 * 24 * 60 * 60 * 1000);
                
                const daysDiff = Math.ceil((task.endDate - task.startDate) / (1000 * 60 * 60 * 24)) + 1;
                task.effortPerDay = task.Effort / daysDiff;
                
                task.Completed = task.Completed === true || task.Completed === 'TRUE' || task.Completed === 1;
            });

            // Atribuir cores sequencialmente para pessoas
            const uniqueAssignees = [...new Set(tasksData.map(task => {
                const originalAssignee = task.Assignee;
                const simplifiedAssignee = originalAssignee ? simplifyAssignee(originalAssignee) : null;
                return simplifiedAssignee ? simplifiedAssignee : `${t('unassigned')} / ${task.Type}`;
            }))].sort();
            
            let colorIndex = 0;
            uniqueAssignees.forEach((assignee) => {
                if (assignee.includes(t('unassigned'))) {
                    assigneeColors[assignee] = '#999999';
                } else {
                    assigneeColors[assignee] = assigneeColorPalette[colorIndex % assigneeColorPalette.length];
                    colorIndex++;
                }
                // Inicializar todos como visíveis
                visibleCategories[assignee] = true;
            });

            // Inicializar tipos como visíveis
            Object.keys(typeColors).forEach(type => {
                visibleCategories[type] = true;
            });

            // Encontrar range de datas
            const allDates = tasksData.flatMap(task => [task.startDate, task.endDate]);
            const minDate = new Date(Math.min(...allDates));
            const maxDate = new Date(Math.max(...allDates));

            originalDateRange.start = minDate.toISOString().split('T')[0];
            originalDateRange.end = maxDate.toISOString().split('T')[0];

            // Mostrar controles
            document.getElementById('controls').style.display = 'flex';
            document.getElementById('filterInfo').style.display = 'block';
            document.getElementById('visualizationContainer').classList.add('active');
            document.getElementById('progressViewBtn').style.display = 'block';

            processData();
            updateVisualization();
        }

        // Toggle visualização de progresso
        function toggleProgressView() {
            progressMode = !progressMode;
            
            if (progressMode) {
                document.getElementById('controls').style.display = 'none';
                document.getElementById('filterInfo').style.display = 'none';
                document.getElementById('progressControls').style.display = 'flex';
                document.getElementById('progressViewBtn').style.display = 'none';
                
                initializeProgressControls();
                updateVisualization();
            } else {
                document.getElementById('controls').style.display = 'flex';
                document.getElementById('filterInfo').style.display = 'block';
                document.getElementById('progressControls').style.display = 'none';
                document.getElementById('progressViewBtn').style.display = 'block';
                
                updateVisualization();
            }
        }

        // Inicializar controles de progresso
        function initializeProgressControls() {
            const monthSelect = document.getElementById('referenceMonth');
            monthSelect.innerHTML = '';
            
            const currentYear = new Date().getFullYear();
            const months = new Set();
            
            tasksData.forEach(task => {
                const startYear = task.startDate.getFullYear();
                const startMonth = task.startDate.getMonth();
                const endYear = task.endDate.getFullYear();
                const endMonth = task.endDate.getMonth();
                
                let currentYearIter = startYear;
                let currentMonth = startMonth;
                
                while (currentYearIter < endYear || (currentYearIter === endYear && currentMonth <= endMonth)) {
                    if (currentYearIter === currentYear) {
                        const monthKey = `${currentYearIter}-${String(currentMonth + 1).padStart(2, '0')}`;
                        months.add(monthKey);
                    }
                    
                    currentMonth++;
                    if (currentMonth > 11) {
                        currentMonth = 0;
                        currentYearIter++;
                    }
                }
            });
            
            const sortedMonths = Array.from(months).sort();
            sortedMonths.forEach(month => {
                const option = document.createElement('option');
                option.value = month;
                const [year, monthNum] = month.split('-');
                const date = new Date(year, parseInt(monthNum) - 1, 1);
                const monthName = date.toLocaleDateString(currentLanguage === 'pt-br' ? 'pt-BR' : 'en-US', { month: 'long', year: 'numeric' });
                option.textContent = monthName;
                monthSelect.appendChild(option);
            });
            
            const today = new Date();
            const currentMonthKey = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}`;
            if (sortedMonths.includes(currentMonthKey)) {
                monthSelect.value = currentMonthKey;
            } else {
                const futureMonth = sortedMonths.find(m => m >= currentMonthKey);
                if (futureMonth) {
                    monthSelect.value = futureMonth;
                } else if (sortedMonths.length > 0) {
                    monthSelect.value = sortedMonths[0];
                }
            }
            
            if (monthSelect.options.length > 0) {
                referenceMonth = monthSelect.value;
                updateProgressCalculations();
            }
        }

        // Atualizar cálculos de progresso
        function updateProgressCalculations() {
            referenceMonth = document.getElementById('referenceMonth').value;
            processData();
            updateVisualization();
        }

        // Processar dados
        function processData() {
            const startDate = new Date(originalDateRange.start);
            const endDate = new Date(originalDateRange.end);
            
            const dataByPeriod = {};
            
            const currentDate = new Date(startDate);
            while (currentDate <= endDate) {
                const dateKey = currentDate.toISOString().split('T')[0];
                dataByPeriod[dateKey] = {
                    date: new Date(currentDate),
                    byType: {},
                    byAssignee: {},
                    byProject: {},
                    total: 0
                };
                currentDate.setDate(currentDate.getDate() + 1);
            }

            // Distribuir esforço das tarefas
            tasksData.forEach(task => {
                const taskStart = new Date(Math.max(task.startDate, startDate));
                const taskEnd = new Date(Math.min(task.endDate, endDate));
                
                if (taskStart <= taskEnd) {
                    const currentDate = new Date(taskStart);
                    while (currentDate <= taskEnd) {
                        const dateKey = currentDate.toISOString().split('T')[0];
                        if (dataByPeriod[dateKey]) {
                            // Por tipo
                            if (!dataByPeriod[dateKey].byType[task.Type]) {
                                dataByPeriod[dateKey].byType[task.Type] = {
                                    effort: 0,
                                    tasks: []
                                };
                            }
                            dataByPeriod[dateKey].byType[task.Type].effort += task.effortPerDay;
                            dataByPeriod[dateKey].byType[task.Type].tasks.push({
                                name: task.Task,
                                project: task.Project,
                                assignee: task.Assignee || t('unassigned'),
                                effort: task.effortPerDay
                            });

                            // Por pessoa
                            const originalAssignee = task.Assignee;
                            const simplifiedAssignee = originalAssignee ? simplifyAssignee(originalAssignee) : null;
                            const assignee = simplifiedAssignee ? simplifiedAssignee : `${t('unassigned')} / ${task.Type}`;
                            
                            if (!dataByPeriod[dateKey].byAssignee[assignee]) {
                                dataByPeriod[dateKey].byAssignee[assignee] = {
                                    effort: 0,
                                    tasks: []
                                };
                            }
                            dataByPeriod[dateKey].byAssignee[assignee].effort += task.effortPerDay;
                            dataByPeriod[dateKey].byAssignee[assignee].tasks.push({
                                name: task.Task,
                                project: task.Project,
                                type: task.Type,
                                effort: task.effortPerDay
                            });

                            // Por projeto
                            if (!dataByPeriod[dateKey].byProject[task.Project]) {
                                dataByPeriod[dateKey].byProject[task.Project] = {
                                    effort: 0,
                                    types: {},
                                    assignees: {}
                                };
                            }
                            dataByPeriod[dateKey].byProject[task.Project].effort += task.effortPerDay;
                            
                            if (!dataByPeriod[dateKey].byProject[task.Project].types[task.Type]) {
                                dataByPeriod[dateKey].byProject[task.Project].types[task.Type] = 0;
                            }
                            dataByPeriod[dateKey].byProject[task.Project].types[task.Type] += task.effortPerDay;

                            if (!dataByPeriod[dateKey].byProject[task.Project].assignees[assignee]) {
                                dataByPeriod[dateKey].byProject[task.Project].assignees[assignee] = 0;
                            }
                            dataByPeriod[dateKey].byProject[task.Project].assignees[assignee] += task.effortPerDay;

                            dataByPeriod[dateKey].total += task.effortPerDay;
                        }
                        currentDate.setDate(currentDate.getDate() + 1);
                    }
                }
            });

            processedData = groupByWeek(dataByPeriod);
            processProjectProgress();
        }

        // Processar progresso dos projetos
        function processProjectProgress() {
            const projects = {};
            const currentYear = new Date().getFullYear();

            tasksData.forEach(task => {
                if (!projects[task.Project]) {
                    projects[task.Project] = {
                        name: task.Project,
                        totalEffort: 0,
                        totalEffortCurrentYear: 0,
                        completedEffort: 0,
                        completedEffortCurrentYear: 0,
                        remainingEffort: 0,
                        remainingEffortCurrentYear: 0,
                        tasks: [],
                        completedTasks: [],
                        pendingTasks: [],
                        monthlyDistribution: {},
                        remainingPercentage: null
                    };
                }

                projects[task.Project].tasks.push(task);
                projects[task.Project].totalEffort += task.Effort;

                const taskHasCurrentYearActivity = (
                    task.startDate.getFullYear() <= currentYear && 
                    task.endDate.getFullYear() >= currentYear
                );

                if (taskHasCurrentYearActivity) {
                    const yearStart = new Date(currentYear, 0, 1);
                    const yearEnd = new Date(currentYear, 11, 31, 23, 59, 59, 999);
                    
                    const taskStartInYear = new Date(Math.max(task.startDate, yearStart));
                    const taskEndInYear = new Date(Math.min(task.endDate, yearEnd));
                    
                    const totalTaskDays = Math.ceil((task.endDate - task.startDate) / (1000 * 60 * 60 * 24)) + 1;
                    const taskDaysInYear = Math.ceil((taskEndInYear - taskStartInYear) / (1000 * 60 * 60 * 24)) + 1;
                    
                    const effortInCurrentYear = (taskDaysInYear / totalTaskDays) * task.Effort;
                    projects[task.Project].totalEffortCurrentYear += effortInCurrentYear;

                    if (task.Completed) {
                        projects[task.Project].completedTasks.push(task);
                        projects[task.Project].completedEffort += task.Effort;
                        projects[task.Project].completedEffortCurrentYear += effortInCurrentYear;
                    } else {
                        projects[task.Project].pendingTasks.push(task);
                        projects[task.Project].remainingEffort += task.Effort;
                        projects[task.Project].remainingEffortCurrentYear += effortInCurrentYear;
                    }
                } else {
                    if (task.Completed) {
                        projects[task.Project].completedTasks.push(task);
                        projects[task.Project].completedEffort += task.Effort;
                    } else {
                        projects[task.Project].pendingTasks.push(task);
                        projects[task.Project].remainingEffort += task.Effort;
                    }
                }
            });

            Object.values(projects).forEach(project => {
                for (let month = 0; month < 12; month++) {
                    const monthKey = `${currentYear}-${String(month + 1).padStart(2, '0')}`;
                    project.monthlyDistribution[monthKey] = {
                        total: 0,
                        completed: 0,
                        remaining: 0
                    };
                }
                
                project.tasks.forEach(task => {
                    const yearStart = new Date(currentYear, 0, 1);
                    const yearEnd = new Date(currentYear, 11, 31, 23, 59, 59, 999);
                    
                    if (task.startDate <= yearEnd && task.endDate >= yearStart) {
                        const taskStartInYear = new Date(Math.max(task.startDate, yearStart));
                        const taskEndInYear = new Date(Math.min(task.endDate, yearEnd));
                        
                        const totalTaskDays = Math.ceil((task.endDate - task.startDate) / (1000 * 60 * 60 * 24)) + 1;
                        const effortPerDay = task.Effort / totalTaskDays;
                        
                        const currentDate = new Date(taskStartInYear);
                        while (currentDate <= taskEndInYear) {
                            const monthKey = `${currentDate.getFullYear()}-${String(currentDate.getMonth() + 1).padStart(2, '0')}`;
                            
                            if (project.monthlyDistribution[monthKey]) {
                                project.monthlyDistribution[monthKey].total += effortPerDay;
                                if (task.Completed) {
                                    project.monthlyDistribution[monthKey].completed += effortPerDay;
                                } else {
                                    project.monthlyDistribution[monthKey].remaining += effortPerDay;
                                }
                            }
                            
                            currentDate.setDate(currentDate.getDate() + 1);
                        }
                    }
                });
                
                project.completedPercentage = project.totalEffortCurrentYear > 0 
                    ? (project.completedEffortCurrentYear / project.totalEffortCurrentYear) * 100 
                    : 0;
                    
                if (progressMode && referenceMonth) {
                    const remainingPercentage = projectRemainingPercentages[project.name];
                    
                    if (remainingPercentage !== null && remainingPercentage !== undefined) {
                        project.remainingPercentage = remainingPercentage;
                        
                        const remainingFromReference = calculateRemainingFromReference(project, referenceMonth);
                        
                        if (remainingFromReference > 0 && remainingPercentage > 0) {
                            const impliedTotal = (remainingFromReference / remainingPercentage) * 100;
                            project.totalEffortAdjusted = impliedTotal;
                            project.completedPercentageAdjusted = (project.completedEffortCurrentYear / impliedTotal) * 100;
                        } else if (remainingPercentage === 0) {
                            project.completedPercentageAdjusted = 100;
                        }
                    } else {
                        const remainingFromReference = calculateRemainingFromReference(project, referenceMonth);
                        project.remainingPercentage = project.totalEffortCurrentYear > 0 
                            ? Math.round((remainingFromReference / project.totalEffortCurrentYear) * 100)
                            : 0;
                        projectRemainingPercentages[project.name] = project.remainingPercentage;
                    }
                }
            });

            projectProgressData = Object.values(projects)
                .filter(project => project.totalEffortCurrentYear > 0)
                .sort((a, b) => b.totalEffortCurrentYear - a.totalEffortCurrentYear);
        }

        // Calcular esforço restante a partir do mês de referência
        function calculateRemainingFromReference(project, referenceMonth) {
            let remaining = 0;
            const currentYear = new Date().getFullYear();
            
            Object.entries(project.monthlyDistribution).forEach(([month, dist]) => {
                const [year] = month.split('-');
                if (parseInt(year) === currentYear && month >= referenceMonth) {
                    remaining += dist.remaining;
                }
            });
            
            return remaining;
        }

        // Agrupar por semana
        function groupByWeek(dailyData) {
            const weeklyData = [];
            const weeks = {};

            Object.entries(dailyData).forEach(([dateKey, data]) => {
                const weekStart = getWeekStart(data.date);
                const weekKey = weekStart.toISOString().split('T')[0];

                if (!weeks[weekKey]) {
                    weeks[weekKey] = {
                        date: weekStart,
                        byType: {},
                        byAssignee: {},
                        byProject: {},
                        total: 0,
                        days: 0
                    };
                }

                Object.entries(data.byType).forEach(([type, typeData]) => {
                    if (!weeks[weekKey].byType[type]) {
                        weeks[weekKey].byType[type] = {
                            effort: 0,
                            tasks: []
                        };
                    }
                    weeks[weekKey].byType[type].effort += typeData.effort;
                    weeks[weekKey].byType[type].tasks.push(...typeData.tasks);
                });

                Object.entries(data.byAssignee).forEach(([assignee, assigneeData]) => {
                    if (!weeks[weekKey].byAssignee[assignee]) {
                        weeks[weekKey].byAssignee[assignee] = {
                            effort: 0,
                            tasks: []
                        };
                    }
                    weeks[weekKey].byAssignee[assignee].effort += assigneeData.effort;
                    weeks[weekKey].byAssignee[assignee].tasks.push(...assigneeData.tasks);
                });

                Object.entries(data.byProject).forEach(([project, projectData]) => {
                    if (!weeks[weekKey].byProject[project]) {
                        weeks[weekKey].byProject[project] = {
                            effort: 0,
                            types: {},
                            assignees: {}
                        };
                    }
                    weeks[weekKey].byProject[project].effort += projectData.effort;
                    
                    Object.entries(projectData.types).forEach(([type, effort]) => {
                        if (!weeks[weekKey].byProject[project].types[type]) {
                            weeks[weekKey].byProject[project].types[type] = 0;
                        }
                        weeks[weekKey].byProject[project].types[type] += effort;
                    });

                    Object.entries(projectData.assignees).forEach(([assignee, effort]) => {
                        if (!weeks[weekKey].byProject[project].assignees[assignee]) {
                            weeks[weekKey].byProject[project].assignees[assignee] = 0;
                        }
                        weeks[weekKey].byProject[project].assignees[assignee] += effort;
                    });
                });

                weeks[weekKey].total += data.total;
                weeks[weekKey].days++;
            });

            return Object.values(weeks).sort((a, b) => a.date - b.date);
        }

        // Obter início da semana
        function getWeekStart(date) {
            const d = new Date(date);
            const day = d.getDay();
            const diff = d.getDate() - day + (day === 0 ? -6 : 1);
            return new Date(d.setDate(diff));
        }

        // Atualizar visualização
        function updateVisualization() {
            const chartDiv = document.getElementById('chart');
            chartDiv.innerHTML = '';

            if (progressMode) {
                drawProgressView();
            } else if (currentVisualizationType === 'stacked') {
                drawStackedChart();
            } else {
                drawSeparateCharts();
            }

            updateLegend();
        }

        // Desenhar visualização de progresso
        function drawProgressView() {
            const container = d3.select('#chart');
            const currentYear = new Date().getFullYear();
            
            const allMonths = new Set();
            projectProgressData.forEach(project => {
                Object.keys(project.monthlyDistribution).forEach(month => {
                    const [year] = month.split('-');
                    if (parseInt(year) === currentYear && month >= referenceMonth) {
                        allMonths.add(month);
                    }
                });
            });
            
            const globalMonths = Array.from(allMonths).sort();
            
            projectProgressData.forEach(project => {
                const projectCard = container.append('div')
                    .attr('class', 'project-card');

                const progressBar = projectCard.append('div')
                    .attr('class', 'project-progress-bar')
                    .on('click', () => openPercentageModal(project.name));

                const remainingPercentage = project.remainingPercentage || 0;
                const completedPercentage = 100 - remainingPercentage;
                
                progressBar.append('div')
                    .attr('class', 'progress-fill')
                    .style('height', completedPercentage + '%');

                progressBar.append('div')
                    .attr('class', 'progress-text')
                    .text(Math.round(completedPercentage) + '%');

                const content = projectCard.append('div')
                    .attr('class', 'project-content');

                const header = content.append('div')
                    .attr('class', 'project-header');

                header.append('div')
                    .attr('class', 'project-name')
                    .text(project.name);

                const stats = header.append('div')
                    .attr('class', 'project-stats');

                const totalEffort = project.totalEffortAdjusted || project.totalEffortCurrentYear;
                stats.append('span')
                    .text(`${t('total-year', {year: currentYear})} ${Math.round(totalEffort)} pts`);

                stats.append('span')
                    .text(`${t('completed')}: ${Math.round(project.completedEffortCurrentYear)} pts`);

                stats.append('span')
                    .text(`${t('accomplished')}: ${Math.round(100 - (project.remainingPercentage || 100))}%`);

                drawProjectTimeline(content, project, globalMonths);
            });
        }

        // Desenhar timeline do projeto (continuação da função anterior, implementação simplificada)
        function drawProjectTimeline(container, project, globalMonths) {
            const currentYear = new Date().getFullYear();
            
            const projectMonthsWithData = [];
            Object.entries(project.monthlyDistribution).forEach(([month, dist]) => {
                const [year] = month.split('-');
                if (parseInt(year) === currentYear && month >= referenceMonth && dist.remaining > 0) {
                    projectMonthsWithData.push(month);
                }
            });
            projectMonthsWithData.sort();
            
            if (projectMonthsWithData.length === 0) {
                container.append('p')
                    .style('padding', '20px')
                    .style('color', '#666')
                    .style('font-style', 'italic')
                    .text(t('no-future-activities', {year: currentYear}));
                return;
            }

            const margin = {top: 10, right: 20, bottom: 5, left: 20};
            const minWidth = 800;
            const monthWidth = Math.max(80, minWidth / Math.max(globalMonths.length, 1));
            const width = Math.max(minWidth, monthWidth * globalMonths.length) - margin.left - margin.right;
            const height = 100 - margin.top - margin.bottom;

            const svg = container.append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .attr('class', 'timeline-chart')
                .style('min-width', (width + margin.left + margin.right) + 'px');

            const g = svg.append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            const remainingPercentage = project.remainingPercentage || 0;
            
            let totalRemainingEffortCurrentYear = 0;
            projectMonthsWithData.forEach(month => {
                totalRemainingEffortCurrentYear += project.monthlyDistribution[month].remaining;
            });
            
            const impliedTotal = remainingPercentage > 0 ? (totalRemainingEffortCurrentYear / remainingPercentage) * 100 : totalRemainingEffortCurrentYear;
            
            const monthlyData = globalMonths.map(month => {
                const dist = project.monthlyDistribution[month];
                
                let percentageRemaining = 0;
                let percentageCompleted = 0;
                let effortRemaining = 0;
                let effortCompleted = 0;
                
                if (dist) {
                    effortRemaining = dist.remaining || 0;
                    effortCompleted = dist.completed || 0;
                    
                    if (impliedTotal > 0) {
                        percentageRemaining = (effortRemaining / impliedTotal) * 100;
                        percentageCompleted = (effortCompleted / impliedTotal) * 100;
                    }
                }
                
                return {
                    month: month,
                    percentageRemaining: percentageRemaining,
                    percentageCompleted: percentageCompleted,
                    effortRemaining: effortRemaining,
                    effortCompleted: effortCompleted,
                    totalPercentage: percentageRemaining + percentageCompleted,
                    totalEffort: effortRemaining + effortCompleted
                };
            });

            const x = d3.scaleBand()
                .domain(globalMonths)
                .range([0, width])
                .padding(0.1);

            let globalMaxPercentage = 0;
            projectProgressData.forEach(proj => {
                const projRemainingPercentage = proj.remainingPercentage || 0;
                let projTotalRemaining = 0;
                let projTotalCompleted = 0;
                
                Object.entries(proj.monthlyDistribution).forEach(([month, dist]) => {
                    const [year] = month.split('-');
                    if (parseInt(year) === currentYear && month >= referenceMonth) {
                        projTotalRemaining += dist.remaining || 0;
                        projTotalCompleted += dist.completed || 0;
                    }
                });
                
                const projImpliedTotal = projRemainingPercentage > 0 ? (projTotalRemaining / projRemainingPercentage) * 100 : (projTotalRemaining + projTotalCompleted);
                
                Object.entries(proj.monthlyDistribution).forEach(([month, dist]) => {
                    const [year] = month.split('-');
                    if (parseInt(year) === currentYear && month >= referenceMonth && projImpliedTotal > 0) {
                        const monthTotalPercentage = ((dist.remaining || 0) + (dist.completed || 0)) / projImpliedTotal * 100;
                        globalMaxPercentage = Math.max(globalMaxPercentage, monthTotalPercentage);
                    }
                });
            });

            const y = d3.scaleLinear()
                .domain([0, Math.max(globalMaxPercentage * 1.1, 5)])
                .range([height, 0]);

            g.append('g')
                .attr('class', 'axis')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x)
                    .tickFormat(d => {
                        const [year, month] = d.split('-');
                        const date = new Date(year, parseInt(month) - 1, 1);
                        return translateMonth(date.toLocaleDateString('en-US', { month: 'short' }), true);
                    })
                )
                .selectAll('text')
                .style('font-weight', 'bold')
                .style('font-size', '12px')
                .style('fill', '#373737');

            const bars = g.selectAll('.month-bar')
                .data(monthlyData)
                .enter().append('g');

            bars.append('rect')
                .attr('class', 'month-bar-completed')
                .attr('x', d => x(d.month))
                .attr('y', d => y(d.percentageCompleted))
                .attr('width', x.bandwidth())
                .attr('height', d => height - y(d.percentageCompleted))
                .attr('fill', '#6CDADE')
                .attr('opacity', d => d.effortCompleted > 0 ? 0.8 : 0)
                .on('mouseover', function(event, d) {
                    if (d.totalEffort > 0) {
                        const tooltip = document.getElementById('tooltip');
                        const [year, month] = d.month.split('-');
                        const date = new Date(year, parseInt(month) - 1, 1);
                        const monthName = date.toLocaleDateString(currentLanguage === 'pt-br' ? 'pt-BR' : 'en-US', { month: 'long', year: 'numeric' });
                        tooltip.innerHTML = `
                            <div class="tooltip-title">${monthName}</div>
                            <div class="tooltip-info">${t('total')}: ${d.totalPercentage.toFixed(1)}% (${Math.round(d.totalEffort)} pts)</div>
                            <div class="tooltip-info">${t('completed-short')}: ${d.percentageCompleted.toFixed(1)}% (${Math.round(d.effortCompleted)} pts)</div>
                            <div class="tooltip-info">${t('remaining')}: ${d.percentageRemaining.toFixed(1)}% (${Math.round(d.effortRemaining)} pts)</div>
                        `;
                        tooltip.style.display = 'block';
                        tooltip.style.left = (event.pageX + 10) + 'px';
                        tooltip.style.top = (event.pageY - 10) + 'px';
                    }
                })
                .on('mouseout', function() {
                    document.getElementById('tooltip').style.display = 'none';
                });

            bars.append('rect')
                .attr('class', 'month-bar-remaining') 
                .attr('x', d => x(d.month))
                .attr('y', d => y(d.totalPercentage))
                .attr('width', x.bandwidth())
                .attr('height', d => y(d.percentageCompleted) - y(d.totalPercentage))
                .attr('fill', '#6F02FD')
                .attr('opacity', d => d.effortRemaining > 0 ? 0.8 : 0)
                .on('mouseover', function(event, d) {
                    if (d.totalEffort > 0) {
                        const tooltip = document.getElementById('tooltip');
                        const [year, month] = d.month.split('-');
                        const date = new Date(year, parseInt(month) - 1, 1);
                        const monthName = date.toLocaleDateString(currentLanguage === 'pt-br' ? 'pt-BR' : 'en-US', { month: 'long', year: 'numeric' });
                        tooltip.innerHTML = `
                            <div class="tooltip-title">${monthName}</div>
                            <div class="tooltip-info">${t('total')}: ${d.totalPercentage.toFixed(1)}% (${Math.round(d.totalEffort)} pts)</div>
                            <div class="tooltip-info">${t('completed-short')}: ${d.percentageCompleted.toFixed(1)}% (${Math.round(d.effortCompleted)} pts)</div>
                            <div class="tooltip-info">${t('remaining')}: ${d.percentageRemaining.toFixed(1)}% (${Math.round(d.effortRemaining)} pts)</div>
                        `;
                        tooltip.style.display = 'block';
                        tooltip.style.left = (event.pageX + 10) + 'px';
                        tooltip.style.top = (event.pageY - 10) + 'px';
                    }
                })
                .on('mouseout', function() {
                    document.getElementById('tooltip').style.display = 'none';
                });

            bars.append('text')
                .attr('x', d => x(d.month) + x.bandwidth() / 2)
                .attr('y', d => d.totalPercentage > 0 ? y(d.totalPercentage) - 5 : y(0) - 5)
                .attr('text-anchor', 'middle')
                .style('font-size', '12px')
                .style('font-weight', '600')
                .style('fill', '#373737')
                .text(d => d.totalPercentage > 0.5 ? d.totalPercentage.toFixed(0) + '%' : '');
        }

        // Abrir modal de input de percentual
        function openPercentageModal(projectName) {
            const project = projectProgressData.find(p => p.name === projectName);
            if (!project) return;
            const currentYear = new Date().getFullYear();
            
            const modalBackdrop = document.createElement('div');
            modalBackdrop.className = 'modal-backdrop';
            
            const modal = document.createElement('div');
            modal.className = 'progress-input-modal';
            
            const remainingPercentage = project.remainingPercentage !== null && project.remainingPercentage !== undefined
                ? project.remainingPercentage
                : Math.round((project.remainingEffortCurrentYear / project.totalEffortCurrentYear) * 100);
            
            modal.innerHTML = `
                <div class="modal-title">${t('remaining-project-percentage', {year: currentYear, project: projectName})}</div>
                <p style="margin-bottom: 15px; color: #666; font-size: 14px;">
                    ${t('inform-percentage', {year: currentYear})}
                </p>
                <input type="number" class="modal-input" id="modalPercentageInput" 
                       value="${remainingPercentage}" min="0" max="100" step="1">
                <p style="margin-bottom: 20px; color: #666; font-size: 12px;">
                    ${t('completed-effort-year', {year: currentYear})} ${Math.round(project.completedEffortCurrentYear)} ${t('points')}<br>
                    ${t('remaining-effort-year', {year: currentYear})} ${Math.round(calculateRemainingFromReference(project, referenceMonth))} ${t('points')}<br>
                    ${t('total-planned-year', {year: currentYear})} ${Math.round(project.totalEffortCurrentYear)} ${t('points')}
                </p>
                <div class="modal-buttons">
                    <button class="modal-button secondary" onclick="closePercentageModal()">${t('cancel')}</button>
                    <button class="modal-button primary" onclick="savePercentage('${projectName}')">${t('save')}</button>
                </div>
            `;
            
            document.body.appendChild(modalBackdrop);
            document.body.appendChild(modal);
            
            document.getElementById('modalPercentageInput').focus();
            document.getElementById('modalPercentageInput').select();
        }

        // Fechar modal
        function closePercentageModal() {
            const modal = document.querySelector('.progress-input-modal');
            const backdrop = document.querySelector('.modal-backdrop');
            if (modal) modal.remove();
            if (backdrop) backdrop.remove();
        }

        // Salvar percentual
        function savePercentage(projectName) {
            const input = document.getElementById('modalPercentageInput');
            const remainingPercentage = parseFloat(input.value) || 0;
            
            projectRemainingPercentages[projectName] = remainingPercentage;
            closePercentageModal();
            
            processData();
            updateVisualization();
        }

        // Desenhar gráfico de barras empilhadas
        function drawStackedChart() {
            const margin = {top: 20, right: 30, bottom: 80, left: 60}; 
            const width = 1300 - margin.left - margin.right;
            const height = 400 - margin.top - margin.bottom;

            const svg = d3.select('#chart')
                .append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom);

            const g = svg.append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            // Filtrar dados visíveis
            const filteredData = processedData.map(d => {
                const filtered = {
                    date: d.date,
                    byType: {},
                    byAssignee: {},
                    byProject: {},
                    total: 0,
                    days: d.days
                };

                if (currentGroupingCategory === 'type') {
                    Object.entries(d.byType).forEach(([type, data]) => {
                        if (visibleCategories[type]) {
                            filtered.byType[type] = data;
                            filtered.total += data.effort;
                        }
                    });
                    filtered.byAssignee = d.byAssignee;
                    filtered.byProject = d.byProject;
                } else {
                    Object.entries(d.byAssignee).forEach(([assignee, data]) => {
                        if (visibleCategories[assignee]) {
                            filtered.byAssignee[assignee] = data;
                            filtered.total += data.effort;
                        }
                    });
                    filtered.byType = d.byType;
                    filtered.byProject = d.byProject;
                }

                return filtered;
            });

            // Escalas
            const x = d3.scaleBand()
                .domain(filteredData.map(d => d.date))
                .range([0, width])
                .padding(0.1);

            const y = d3.scaleLinear()
                .domain([0, d3.max(filteredData, d => d.total) * 1.1])
                .range([height, 0]);

            // Grid
            g.append('g')
                .attr('class', 'grid')
                .call(d3.axisLeft(y)
                    .tickSize(-width)
                    .tickFormat('')
                );

            // Eixo X customizado com 3 níveis
            const xAxis = g.append('g')
                .attr('class', 'axis')
                .attr('transform', `translate(0,${height})`);

            const weeks = filteredData.map((d, i) => ({
                date: d.date,
                index: i,
                weekNum: Math.floor(i) + 1,
                month: d.date.toLocaleDateString('en-US', { month: 'short' }),
                year: d.date.getFullYear()
            }));

            xAxis.append('line')
                .attr('x1', 0)
                .attr('x2', width)
                .attr('y1', 0)
                .attr('y2', 0)
                .attr('stroke', '#ddd');

            weeks.forEach((week, i) => {
                const xPos = x(week.date) + x.bandwidth() / 2;
                
                xAxis.append('line')
                    .attr('x1', xPos)
                    .attr('x2', xPos)
                    .attr('y1', 0)
                    .attr('y2', 6)
                    .attr('stroke', '#ddd');
                
                xAxis.append('text')
                    .attr('x', xPos)
                    .attr('y', 15)
                    .attr('text-anchor', 'middle')
                    .style('font-size', '10px')
                    .style('fill', '#666')
                    .text(week.weekNum);
            });

            let currentMonth = '';
            weeks.forEach((week, i) => {
                const monthName = translateMonth(week.month, true);
                const monthYear = `${monthName}-${week.year}`;
                
                if (monthYear !== currentMonth) {
                    currentMonth = monthYear;
                    const xPos = x(week.date);
                    
                    const monthGroup = xAxis.append('g')
                        .style('cursor', 'pointer')
                        .on('click', function() {
                            filterByMonth(week.date);
                        })
                        .on('mouseover', function() {
                            d3.select(this).select('text')
                                .style('fill', '#6F02FD');
                        })
                        .on('mouseout', function() {
                            d3.select(this).select('text')
                                .style('fill', '#373737');
                        });
                    
                    monthGroup.append('text')
                        .attr('x', xPos + 10)
                        .attr('y', 30)
                        .attr('text-anchor', 'start')
                        .style('font-size', '12px')
                        .style('font-weight', 'bold')
                        .style('fill', '#373737')
                        .text(monthName.charAt(0).toUpperCase() + monthName.slice(1));
                }
            });

            let processedYears = new Set();
            weeks.forEach((week, i) => {
                if (!processedYears.has(week.year)) {
                    processedYears.add(week.year);
                    const xPos = x(week.date);
                    
                    const yearGroup = xAxis.append('g')
                        .style('cursor', 'pointer')
                        .on('click', function() {
                            filterByYear(week.year);
                        })
                        .on('mouseover', function() {
                            d3.select(this).select('text')
                                .style('fill', '#2C0165');
                        })
                        .on('mouseout', function() {
                            d3.select(this).select('text')
                                .style('fill', '#373737');
                        });
                    
                    yearGroup.append('text')
                        .attr('x', xPos + 10)
                        .attr('y', 50)
                        .attr('text-anchor', 'start')
                        .style('font-size', '14px')
                        .style('font-weight', 'bold')
                        .style('fill', '#373737')
                        .text(week.year);
                }
            });

            xAxis.append('text')
                .attr('x', -40)
                .attr('y', 15)
                .style('font-size', '10px')
                .style('fill', '#999')
                .text(t('week-short'));

            g.append('g')
                .attr('class', 'axis')
                .call(d3.axisLeft(y));

            g.append('text')
                .attr('transform', 'rotate(-90)')
                .attr('y', 0 - margin.left)
                .attr('x', 0 - (height / 2))
                .attr('dy', '1em')
                .style('text-anchor', 'middle')
                .style('font-size', '14px')
                .style('fill', '#666')
                .text(t('effort-label'));

            // Preparar categorias visíveis
            let categories;
            let colors;
            
            if (currentGroupingCategory === 'type') {
                categories = Object.keys(visibleCategories).filter(k => visibleCategories[k] && typeColors[k]).sort();
                colors = typeColors;
            } else {
                const allAssignees = Object.keys(visibleCategories).filter(k => visibleCategories[k] && assigneeColors[k]);
                const realPeople = allAssignees.filter(a => !a.includes(t('unassigned'))).sort();
                const unassigned = allAssignees.filter(a => a.includes(t('unassigned'))).sort();
                categories = [...realPeople, ...unassigned];
                colors = assigneeColors;
            }

            // Desenhar barras empilhadas
            filteredData.forEach(d => {
                let yOffset = 0;
                
                categories.forEach(category => {
                    const categoryData = currentGroupingCategory === 'type' ? d.byType[category] : d.byAssignee[category];
                    
                    if (categoryData && categoryData.effort > 0) {
                        const projectTasks = {};
                        categoryData.tasks.forEach(task => {
                            if (!projectTasks[task.project]) {
                                projectTasks[task.project] = 0;
                            }
                            projectTasks[task.project] += task.effort;
                        });

                        Object.entries(projectTasks).forEach(([project, effort]) => {
                            const barHeight = y(0) - y(effort);
                            
                            g.append('rect')
                                .attr('class', 'bar-segment')
                                .attr('data-category', category)
                                .attr('data-project', project)
                                .attr('x', x(d.date))
                                .attr('y', y(yOffset + effort))
                                .attr('width', x.bandwidth())
                                .attr('height', barHeight)
                                .attr('fill', colors[category] || '#999')
                                .attr('opacity', 0.9)
                                .style('cursor', 'pointer')
                                .on('click', function(event) {
                                    event.stopPropagation();
                                    toggleProjectSelection(project);
                                })
                                .on('mouseover', function(event) {
                                    showTooltip(event, processedData.find(pd => pd.date.getTime() === d.date.getTime()), category, project);
                                    if (!selectedProject) {
                                        highlightProject(project);
                                    }
                                })
                                .on('mouseout', function() {
                                    hideTooltip();
                                    if (!selectedProject) {
                                        clearProjectHighlight();
                                    }
                                });

                            yOffset += effort;
                        });
                    }
                });
            });

            addTodayLine(g, filteredData, x, height);
        }

        // Desenhar gráficos separados
        function drawSeparateCharts() {
            let categories;
            let colors;
            
            if (currentGroupingCategory === 'type') {
                categories = Object.keys(visibleCategories).filter(k => visibleCategories[k] && typeColors[k]).sort();
                colors = typeColors;
            } else {
                const allAssignees = Object.keys(visibleCategories).filter(k => visibleCategories[k] && assigneeColors[k]);
                const realPeople = allAssignees.filter(a => !a.includes(t('unassigned'))).sort();
                const unassigned = allAssignees.filter(a => a.includes(t('unassigned'))).sort();
                categories = [...realPeople, ...unassigned];
                colors = assigneeColors;
            }

            const margin = {top: 20, right: 30, bottom: 60, left: 60};
            const width = 1300 - margin.left - margin.right;
            const heightPerChart = 150;

            let globalMaxEffort = 0;
            categories.forEach(category => {
                const categoryData = processedData.map(d => {
                    const dataForCategory = currentGroupingCategory === 'type' ? d.byType[category] : d.byAssignee[category];
                    return dataForCategory?.effort || 0;
                });
                const maxInCategory = d3.max(categoryData) || 0;
                globalMaxEffort = Math.max(globalMaxEffort, maxInCategory);
            });

            const globalY = d3.scaleLinear()
                .domain([0, globalMaxEffort * 1.1])
                .range([heightPerChart, 0]);

            categories.forEach((category, index) => {
                const svg = d3.select('#chart')
                    .append('svg')
                    .attr('width', width + margin.left + margin.right)
                    .attr('height', heightPerChart + margin.top + margin.bottom)
                    .style('margin-bottom', '20px');

                const g = svg.append('g')
                    .attr('transform', `translate(${margin.left},${margin.top})`);

                g.append('text')
                    .attr('x', 0)
                    .attr('y', -5)
                    .style('font-size', '14px')
                    .style('font-weight', 'bold')
                    .style('fill', colors[category] || '#999')
                    .text(category);

                const categoryData = processedData.map(d => {
                    const dataForCategory = currentGroupingCategory === 'type' ? d.byType[category] : d.byAssignee[category];
                    return {
                        date: d.date,
                        effort: dataForCategory?.effort || 0,
                        projects: dataForCategory?.tasks || []
                    };
                });

                const x = d3.scaleBand()
                    .domain(categoryData.map(d => d.date))
                    .range([0, width])
                    .padding(0.1);

                g.append('g')
                    .attr('class', 'grid')
                    .call(d3.axisLeft(globalY)
                        .tickSize(-width)
                        .tickFormat('')
                        .ticks(4)
                    );

                if (currentGroupingCategory === 'assignee' && globalMaxEffort >= 7) {
                    g.append('line')
                        .attr('class', 'reference-line')
                        .attr('x1', 0)
                        .attr('x2', width)
                        .attr('y1', globalY(7))
                        .attr('y2', globalY(7));

                    g.append('text')
                        .attr('class', 'reference-text')
                        .attr('x', width - 5)
                        .attr('y', globalY(7) - 3)
                        .text('70%');
                }

                if (currentGroupingCategory === 'assignee' && globalMaxEffort >= 10) {
                    g.append('line')
                        .attr('class', 'reference-line')
                        .attr('x1', 0)
                        .attr('x2', width)
                        .attr('y1', globalY(10))
                        .attr('y2', globalY(10));

                    g.append('text')
                        .attr('class', 'reference-text')
                        .attr('x', width - 5)
                        .attr('y', globalY(10) - 3)
                        .text('100%');
                }

                const xAxis = g.append('g')
                    .attr('class', 'axis')
                    .attr('transform', `translate(0,${heightPerChart})`);

                const weeks = categoryData.map((d, i) => ({
                    date: d.date,
                    index: i,
                    weekNum: Math.floor(i) + 1,
                    month: d.date.toLocaleDateString('en-US', { month: 'short' }),
                    year: d.date.getFullYear()
                }));

                xAxis.append('line')
                    .attr('x1', 0)
                    .attr('x2', width)
                    .attr('y1', 0)
                    .attr('y2', 0)
                    .attr('stroke', '#ddd');

                weeks.forEach((week, i) => {
                    const xPos = x(week.date) + x.bandwidth() / 2;
                    
                    xAxis.append('line')
                        .attr('x1', xPos)
                        .attr('x2', xPos)
                        .attr('y1', 0)
                        .attr('y2', 6)
                        .attr('stroke', '#ddd');
                    
                    xAxis.append('text')
                        .attr('x', xPos)
                        .attr('y', 15)
                        .attr('text-anchor', 'middle')
                        .style('font-size', '10px')
                        .style('fill', '#666')
                        .text(week.weekNum);
                });

                let currentMonth = '';
                weeks.forEach((week, i) => {
                    const monthName = translateMonth(week.month, true);
                    const monthYear = `${monthName}-${week.year}`;
                    
                    if (monthYear !== currentMonth) {
                        currentMonth = monthYear;
                        const xPos = x(week.date);
                        
                        const monthGroup = xAxis.append('g')
                            .style('cursor', 'pointer')
                            .on('click', function() {
                                filterByMonth(week.date);
                            })
                            .on('mouseover', function() {
                                d3.select(this).select('text')
                                    .style('fill', '#6F02FD');
                            })
                            .on('mouseout', function() {
                                d3.select(this).select('text')
                                    .style('fill', '#373737');
                            });
                        
                        monthGroup.append('text')
                            .attr('x', xPos + 10)
                            .attr('y', 30)
                            .attr('text-anchor', 'start')
                            .style('font-size', '12px')
                            .style('font-weight', 'bold')
                            .style('fill', '#373737')
                            .text(monthName.charAt(0).toUpperCase() + monthName.slice(1));
                    }
                });

                let processedYears = new Set();
                weeks.forEach((week, i) => {
                    if (!processedYears.has(week.year)) {
                        processedYears.add(week.year);
                        const xPos = x(week.date);
                        
                        const yearGroup = xAxis.append('g')
                            .style('cursor', 'pointer')
                            .on('click', function() {
                                filterByYear(week.year);
                            })
                            .on('mouseover', function() {
                                d3.select(this).select('text')
                                    .style('fill', '#2C0165');
                            })
                            .on('mouseout', function() {
                                d3.select(this).select('text')
                                    .style('fill', '#373737');
                            });
                        
                        yearGroup.append('text')
                            .attr('x', xPos + 10)
                            .attr('y', 50)
                            .attr('text-anchor', 'start')
                            .style('font-size', '14px')
                            .style('font-weight', 'bold')
                            .style('fill', '#373737')
                            .text(week.year);
                    }
                });

                xAxis.append('text')
                    .attr('x', -40)
                    .attr('y', 15)
                    .style('font-size', '10px')
                    .style('fill', '#999')
                    .text(t('week-short'));

                g.append('g')
                    .attr('class', 'axis')
                    .call(d3.axisLeft(globalY).ticks(4));

                g.selectAll('.bar')
                    .data(categoryData)
                    .enter().each(function(d) {
                        if (d.effort > 0) {
                            const barX = x(d.date);
                            const projectEfforts = {};
                            
                            d.projects.forEach(task => {
                                if (!projectEfforts[task.project]) {
                                    projectEfforts[task.project] = 0;
                                }
                                projectEfforts[task.project] += task.effort;
                            });

                            let yOffset = 0;
                            Object.entries(projectEfforts).forEach(([project, effort]) => {
                                const segmentHeight = (effort / d.effort) * (globalY(0) - globalY(d.effort));
                                
                                d3.select(this).append('rect')
                                    .attr('class', 'bar-segment')
                                    .attr('data-category', category)
                                    .attr('data-project', project)
                                    .attr('x', barX)
                                    .attr('y', globalY(d.effort) + yOffset)
                                    .attr('width', x.bandwidth())
                                    .attr('height', segmentHeight)
                                    .attr('fill', colors[category] || '#999')
                                    .attr('opacity', 0.9)
                                    .style('cursor', 'pointer')
                                    .on('click', function(event) {
                                        event.stopPropagation();
                                        toggleProjectSelection(project);
                                    })
                                    .on('mouseover', function(event) {
                                        const periodData = processedData.find(pd => pd.date === d.date);
                                        showTooltip(event, periodData, category, project);
                                        if (!selectedProject) {
                                            highlightProject(project);
                                        }
                                    })
                                    .on('mouseout', function() {
                                        hideTooltip();
                                        if (!selectedProject) {
                                            clearProjectHighlight();
                                        }
                                    });

                                yOffset += segmentHeight;
                            });
                        }
                    });

                addTodayLine(g, categoryData, x, heightPerChart);
            });
        }

        // Função auxiliar para adicionar linha "hoje"
        function addTodayLine(g, data, x, height) {
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            
            const todayInRange = data.find(d => {
                const weekStart = getWeekStart(d.date);
                const weekEnd = new Date(weekStart);
                weekEnd.setDate(weekEnd.getDate() + 6);
                weekEnd.setHours(23, 59, 59, 999);
                
                return today >= weekStart && today <= weekEnd;
            });
            
            if (todayInRange) {
                const weekStart = getWeekStart(todayInRange.date);
                const dayOfWeek = Math.floor((today - weekStart) / (1000 * 60 * 60 * 24));
                const todayX = x(todayInRange.date) + (x.bandwidth() * dayOfWeek / 7);
                
                g.append('line')
                    .attr('class', 'today-line')
                    .attr('x1', todayX)
                    .attr('x2', todayX)
                    .attr('y1', 0)
                    .attr('y2', height)
                    .attr('stroke', '#373737')
                    .attr('stroke-width', 2)
                    .attr('stroke-dasharray', '5,5')
                    .style('pointer-events', 'none');
                
                g.append('text')
                    .attr('x', todayX + 5)
                    .attr('y', 15)
                    .style('font-size', '12px')
                    .style('font-weight', 'bold')
                    .style('fill', '#373737')
                    .style('pointer-events', 'none')
                    .text(t('today'));
            }
        }

        // Toggle seleção de projeto
        function toggleProjectSelection(project) {
            if (selectedProject === project) {
                selectedProject = null;
                clearProjectHighlight();
            } else {
                selectedProject = project;
                highlightProject(project);
            }
        }

        // Destacar projeto
        function highlightProject(project) {
            highlightedProject = project;
            
            d3.selectAll('.bar-segment')
                .attr('opacity', function() {
                    return d3.select(this).attr('data-project') === project ? 1 : 0.3;
                });

            d3.selectAll(`.bar-segment[data-project="${project}"]`)
                .style('stroke', '#373737')
                .style('stroke-width', 2);
        }

        // Limpar destaque
        function clearProjectHighlight() {
            highlightedProject = null;
            
            d3.selectAll('.bar-segment')
                .attr('opacity', 0.9)
                .style('stroke', 'none');
        }

        // Clique fora das barras para limpar seleção
        document.addEventListener('click', function(event) {
            if (!event.target.classList.contains('bar-segment') && selectedProject) {
                selectedProject = null;
                clearProjectHighlight();
            }
        });

        // Mostrar tooltip
        function showTooltip(event, data, category, project) {
            const tooltip = document.getElementById('tooltip');
            const projectData = data.byProject[project];
            
            let content = `<div class="tooltip-title">${project}</div>`;
            content += `<div class="tooltip-info">${t('date')}: ${data.date.toLocaleDateString(currentLanguage === 'pt-br' ? 'pt-BR' : 'en-US')}</div>`;
            content += `<div class="tooltip-info">${t('project-effort')}: ${projectData.effort.toFixed(1)} ${t('points')}</div>`;
            
            if (currentGroupingCategory === 'type') {
                const typeEffort = data.byType[category]?.effort || 0;
                content += `<div class="tooltip-info">${t('total-effort-in')} ${category}: ${typeEffort.toFixed(1)} ${t('points')}</div>`;
                
                const assigneesInType = Object.entries(projectData.assignees || {})
                    .filter(([assignee, effort]) => effort > 0);
                
                if (assigneesInType.length > 0) {
                    content += '<div style="margin-top: 8px; border-top: 1px solid #666; padding-top: 8px;">';
                    content += `<div style="font-weight: bold; margin-bottom: 4px;">${t('people-in-project')}</div>`;
                    assigneesInType.forEach(([assignee, effort]) => {
                        content += `<div style="font-size: 11px;">• ${assignee}: ${effort.toFixed(1)} pts</div>`;
                    });
                    content += '</div>';
                }
            } else {
                const assigneeEffort = data.byAssignee[category]?.effort || 0;
                content += `<div class="tooltip-info">${t('total-effort-of')} ${category}: ${assigneeEffort.toFixed(1)} ${t('points')}</div>`;
                
                const typesForAssignee = Object.entries(projectData.types || {})
                    .filter(([type, effort]) => effort > 0);
                
                if (typesForAssignee.length > 0) {
                    content += '<div style="margin-top: 8px; border-top: 1px solid #666; padding-top: 8px;">';
                    content += `<div style="font-weight: bold; margin-bottom: 4px;">${t('work-types')}</div>`;
                    typesForAssignee.forEach(([type, effort]) => {
                        content += `<div style="font-size: 11px;">• ${type}: ${effort.toFixed(1)} pts</div>`;
                    });
                    content += '</div>';
                }
            }
            
            content += `<div class="tooltip-info" style="font-weight: bold; margin-top: 4px;">${t('total-general-effort')}: ${data.total.toFixed(1)} ${t('points')}</div>`;
            
            tooltip.innerHTML = content;
            tooltip.style.display = 'block';
            
            const mouseX = event.pageX || event.clientX + window.scrollX;
            const mouseY = event.pageY || event.clientY + window.scrollY;
            
            const tooltipRect = tooltip.getBoundingClientRect();
            let left = mouseX + 10;
            let top = mouseY - tooltipRect.height - 10;
            
            if (left + tooltipRect.width > window.innerWidth - 20) {
                left = mouseX - tooltipRect.width - 10;
            }
            
            if (top < 20) {
                top = mouseY + 10;
            }
            
            tooltip.style.left = left + 'px';
            tooltip.style.top = top + 'px';
        }

        // Esconder tooltip
        function hideTooltip() {
            document.getElementById('tooltip').style.display = 'none';
        }

        // Atualizar legenda com funcionalidade de toggle
        function updateLegend() {
            const legend = document.getElementById('legend');
            legend.innerHTML = '';

            // Não mostrar legenda para visualização de progresso
            if (progressMode) {
                legend.style.display = 'none';
                return;
            }

            legend.style.display = 'flex';

            let items;
            let colors;
            
            if (currentGroupingCategory === 'type') {
                items = [...new Set(tasksData.map(t => t.Type))].sort();
                colors = typeColors;
            } else {
                const allAssignees = [...new Set(tasksData.map(task => {
                    const originalAssignee = task.Assignee;
                    const simplifiedAssignee = originalAssignee ? simplifyAssignee(originalAssignee) : null;
                    return simplifiedAssignee ? simplifiedAssignee : `${t('unassigned')} / ${task.Type}`;
                }))];
                
                const realPeople = allAssignees.filter(a => !a.includes(t('unassigned'))).sort();
                const unassigned = allAssignees.filter(a => a.includes(t('unassigned'))).sort();
                items = [...realPeople, ...unassigned];
                colors = assigneeColors;
            }

            items.forEach(item => {
                const isVisible = visibleCategories[item];
                
                const legendItem = document.createElement('div');
                legendItem.className = 'legend-item';
                if (!isVisible) {
                    legendItem.classList.add('inactive');
                }
                
                legendItem.innerHTML = `
                    <div class="legend-color" style="background: ${colors[item] || '#999'}"></div>
                    <span>${item}</span>
                `;
                
                legendItem.onclick = () => toggleLegendItem(item);
                legend.appendChild(legendItem);
            });
        }

        // Toggle item da legenda
        function toggleLegendItem(item) {
            // Apenas permitir toggle para visualização por pessoa
            if (currentGroupingCategory !== 'assignee') {
                return;
            }

            // Toggle visibilidade
            visibleCategories[item] = !visibleCategories[item];
            
            // Redesenhar visualização
            updateVisualization();
        }

        // Resetar para período completo
        function resetDateRange() {
            if (originalDateRange.start && originalDateRange.end) {
                processData();
                updateVisualization();
            }
        }

        // Filtrar por mês
        function filterByMonth(date) {
            const monthStart = new Date(date.getFullYear(), date.getMonth(), 1);
            const monthEnd = new Date(date.getFullYear(), date.getMonth() + 1, 0);
            
            const filteredData = processedData.filter(d => {
                return d.date >= monthStart && d.date <= monthEnd;
            });
            
            if (filteredData.length > 0) {
                processedData = filteredData;
                updateVisualization();
            }
        }

        // Filtrar por ano
        function filterByYear(year) {
            const yearStart = new Date(year, 0, 1);
            const yearEnd = new Date(year, 11, 31, 23, 59, 59, 999);
            
            const filteredData = processedData.filter(d => {
                return d.date >= yearStart && d.date <= yearEnd;
            });
            
            if (filteredData.length > 0) {
                processedData = filteredData;
                updateVisualization();
            }
        }

        // Funções de controle
        function setVisualizationType(type) {
            currentVisualizationType = type;
            document.getElementById('stackedBtn').classList.toggle('active', type === 'stacked');
            document.getElementById('separateBtn').classList.toggle('active', type === 'separate');
            updateVisualization();
        }

        function setGroupingCategory(category) {
            currentGroupingCategory = category;
            document.getElementById('typeBtn').classList.toggle('active', category === 'type');
            document.getElementById('assigneeBtn').classList.toggle('active', category === 'assignee');
            processData();
            updateVisualization();
        }
    </script>
</body>
</html>
